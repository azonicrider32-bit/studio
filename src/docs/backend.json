{
  "entities": {
    "Asset": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Asset",
      "type": "object",
      "description": "Represents an asset stored in Google Cloud Storage.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the asset."
        },
        "userId": {
          "type": "string",
          "description": "Reference to the User who owns the asset. (Relationship: User 1:N Asset)"
        },
        "gcsBucket": {
          "type": "string",
          "description": "Name of the Google Cloud Storage bucket where the asset is stored."
        },
        "gcsPath": {
          "type": "string",
          "description": "Path to the asset within the Google Cloud Storage bucket."
        },
        "assetType": {
          "type": "string",
          "description": "Type of asset (e.g., 'image', 'video', 'audio', 'segmentation-mask')."
        },
        "uploadDate": {
          "type": "string",
          "description": "Date and time when the asset was uploaded to Google Cloud Storage.",
          "format": "date-time"
        },
        "fileSize": {
          "type": "number",
          "description": "Size of the asset file in bytes."
        },
        "originalName": {
          "type": "string",
          "description": "Original name of the uploaded file."
        },
        "accessControl": {
          "type": "string",
          "description": "Access control settings for the asset in Google Cloud Storage (e.g., 'publicRead', 'private')."
        },
        "tags": {
          "type": "array",
          "description": "Tags associated with the asset for organizational purposes.",
          "items": {
            "type": "string"
          }
        },
        "metadata": {
          "type": "string",
          "description": "Stores the asset's metadata in json string format."
        }
      },
      "required": [
        "id",
        "userId",
        "gcsBucket",
        "gcsPath",
        "assetType",
        "uploadDate"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "username": {
          "type": "string",
          "description": "Username of the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "username",
        "email"
      ]
    },
    "PerformanceLog": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PerformanceLog",
      "type": "object",
      "description": "Represents a single performance event log.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the log entry."
        },
        "userId": {
          "type": "string",
          "description": "The ID of the user who triggered the event."
        },
        "timestamp": {
          "type": "object",
          "description": "The server timestamp when the log was created."
        },
        "type": {
          "type": "string",
          "enum": ["performance", "ai_call", "error"],
          "description": "The category of the event."
        },
        "tool": {
          "type": "string",
          "description": "The tool being used (e.g., 'magic-wand', 'lasso', 'banana')."
        },
        "operation": {
          "type": "string",
          "description": "The specific operation being measured (e.g., 'selection', 'inpaintWithPrompt')."
        },
        "duration": {
          "type": "number",
          "description": "The duration of the operation in milliseconds."
        },
        "context": {
          "type": "object",
          "description": "Additional context about the event, such as image size or layer count."
        },
        "description": {
          "type": "string",
          "description": "A natural language summary of the performance event, generated by AI."
        }
      },
      "required": [
        "id",
        "userId",
        "timestamp",
        "type",
        "description"
      ]
    },
    "CustomAiTool": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "CustomAiTool",
      "type": "object",
      "description": "Represents a user-created AI tool with a configurable prompt and UI.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the custom tool."
        },
        "userId": {
          "type": "string",
          "description": "The ID of the user who created this tool."
        },
        "name": {
          "type": "string",
          "description": "The display name of the tool."
        },
        "description": {
          "type": "string",
          "description": "A brief description of what the tool does."
        },
        "icon": {
          "type": "string",
          "description": "An icon identifier (e.g., from Lucide icons) for the tool's button."
        },
        "promptTemplate": {
          "type": "string",
          "description": "A Handlebars-style template string for the AI prompt. It can include placeholders like {{mask}} and {{custom_param_1}}."
        },
        "uiDefinition": {
          "type": "array",
          "description": "An array of objects defining the custom UI controls for this tool.",
          "items": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "The key to use for this parameter in the prompt template (e.g., 'custom_param_1')."
              },
              "label": {
                "type": "string",
                "description": "The display label for the UI control."
              },
              "type": {
                "type": "string",
                "enum": ["slider", "switch", "select", "text"],
                "description": "The type of UI control to render."
              },
              "defaultValue": {
                "type": ["string", "number", "boolean"],
                "description": "The default value for the control."
              },
              "options": {
                "type": "object",
                "description": "Configuration options for the control (e.g., min/max for a slider, items for a select dropdown)."
              }
            },
            "required": ["id", "label", "type", "defaultValue"]
          }
        }
      },
      "required": ["id", "userId", "name", "promptTemplate"]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.  Authorization is based on user ID in the path.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/assets/{assetId}",
        "definition": {
          "entityName": "Asset",
          "schema": {
            "$ref": "#/backend/entities/Asset"
          },
          "description": "Stores assets owned by a specific user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns the asset."
            },
            {
              "name": "assetId",
              "description": "The unique identifier of the asset."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/performanceLogs/{logId}",
        "definition": {
          "entityName": "PerformanceLog",
          "schema": {
            "$ref": "#/backend/entities/PerformanceLog"
          },
          "description": "Stores performance log entries for a specific user.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user associated with the log."
            },
            {
              "name": "logId",
              "description": "The unique identifier of the performance log entry."
            }
          ]
        }
      },
       {
        "path": "/users/{userId}/customAiTools/{toolId}",
        "definition": {
          "entityName": "CustomAiTool",
          "schema": {
            "$ref": "#/backend/entities/CustomAiTool"
          },
          "description": "Stores user-created custom AI tools.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who created the tool."
            },
            {
              "name": "toolId",
              "description": "The unique identifier of the custom tool."
            }
          ]
        }
      }
    ],
    "reasoning": "This Firestore data structure is designed to efficiently manage assets, user data, and roles while adhering to the core design principles of Authorization Independence, Clarity of Intent, DBAC, and QAPs. It leverages structural segregation and denormalization to create a secure, scalable, and debuggable system.\n\nThe primary segregation strategy is to store user-owned assets under their respective user IDs. This eliminates the need for complex queries or security rules based on document content. Additionally, each document within a collection maintains a homogeneous security posture, and this ensures each document in the 'assets' collection share the same security requirements, simplifying the rules.\n\nAuthorization Independence is achieved by storing assets under user-specific paths, enabling path-based security rules that directly associate assets with their owners. Specifically, the `/users/{userId}/assets/{assetId}` structure facilitates security rules that permit only the user with the matching 'userId' to read, write, or delete assets. This design avoids `get()` calls in security rules by design, so rules will not depend on the parent document.\n\nThe QAP (Rules are not Filters) principle is supported through structural segregation. Listing operations can be secured by filtering assets based on the 'userId' in the path. This allows for efficient and secure listing of assets owned by a specific user without requiring rules to filter based on document data.\n\nOwnership invariants are maintained by enforcing the 'userId' in the asset document to match the 'userId' in the path. Timestamps can be easily added and managed within the asset documents, and denormalized data (e.g., asset counts) can be maintained in user documents via Cloud Functions triggered by asset creation or deletion."
  }
}

    